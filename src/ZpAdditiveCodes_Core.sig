175,0
S,ZpAdditiveCodes_Core_version,Return the current version of this package,0,0,0,0,0,0,0,82,-38,-38,-38,-38,-38
S,CarletGrayMap,"Given a prime p and an integer s>1, this function returns Carlet's generalized Grap map phi_s from Z/(p^s)^n to Zp^(p^(s-1))",0,2,0,0,0,0,0,0,0,148,,0,0,148,,175,-38,-38,-38,-38,-38
S,CarletGrayMap,"Given a linear code C over Z/p^s of length n, this function returns Carlet's generalized Gray map for C. This is the map phi_s from C to Zp^(n*p^(s-1)). If the linear code C is over Z4, function CarletGrayMap(C) coincides with function GrayMap(C), which works only for linear codes over Z4",0,1,0,0,0,0,0,0,0,202,,175,-38,-38,-38,-38,-38
S,CarletGrayMapImage,"Given a code C over Z/p^s of length n, this function returns the image of C under Carlet's generalized Gray map as a sequence of vectors in GF(p)^(n*p^(s-1)). As the resulting image may not be a linear code over GF(p), a sequence of vectors is returned rather than a code. If the linear code C is over Z4, function CarletGrayMapImage(C) coincides with GrayMapImage(C), which works only for linear codes over Z4",0,1,0,0,0,0,0,0,0,202,,82,-38,-38,-38,-38,-38
S,CarletGrayMap,"Given a prime p and a sequence T=[t1,...,ts] of s nonnegative integers, this function returns a map from the (Z/p^s)-submodule of (Z/p^s)^(t1+...+ts) isomorphic to (Z/p^s)^t1 x ... x Zp^ts to the space Zp^k, where k=t1*p^(s-1) + t2*p^(s-2) + ... + ts. In the first t1 coordinates, Carlet's generalized Gray map phi_s from Z/p^s to Zp^(p^(s-1)) is considered; in the next t2, Carlet's generalized Gray map phi_(s-1) from Z/p^(s-1) to Zp^(p^(s-2)); and so on, until the last ts coordinates, where the identity map phi_1 form Zp to Zp is considered. The map is also provided with an inverse function, since it is bijective. Note that this map coincides with Carlet's generalized Gray map from the information space of a linear code C over Z/p^s of type (n; t1,...,ts) (as a Z/p^s-submodule) to the information space of phi_s(C)",1,1,1,82,0,148,2,0,0,0,0,0,0,0,82,,0,0,148,,175,-38,-38,-38,-38,-38
S,HasLinearCarletGrayMapImage,"Given a linear code C over Z/p^s of length n, this function returns true if and only if the image of C under Carlet's generalized Gray map is a linear code over Zp. If so, the function also returns the image C_p as a linear code over Zp, together with the bijection phi_s: C -> C_p. The user can specify the method to be used by setting the parameter AlgMethod to ""BruteForce"", ""StarProduct"" or ""StarProductMemory"". The first one is based on computing the span of the Gray map image of C, and the other two on Theorem 4.13 given in the below reference, without considering some of the codewords of order p. ""StarProductMemory"" method does more computations than ""StarProduct"", but it does not need to store any set of codewords. By default, AlgMethod is set to ""StarProduct"". However, sometimes the brute force method can be faster, for example, when the image of C under Carlet’s Gray map gives a linear code over Fp, that is, when almost all pairs of codewords need to be checked in the default method. In cases where there is not enough memory to perform the default method, the option ""StarProductMemory"" can be used. If the linear code C is over Z4, HasLinearCarletGrayMapImage(C) coincides with function HasLinearGrayMapImage(C), which works only for linear codes over Z4. Reference: Tapia-Recillas, H., Vega, G.: On Z2k-linear and quaternary codes. SIAM J. Discrete Math. 17(1), pp. 103–113, 2003",0,1,0,0,0,0,0,0,0,202,,36,202,175,-38,-38,-38
S,IsHadamardMatrix,"Returns true if and only if H is a generalized Hadamard matrix over Fq or an ordinary Hadamard matrix of +1's and -1's. If H is an ordinary Hadamard matrix, the return is the same as that of function IsHadamard(H)",0,1,0,0,0,0,0,0,0,177,,36,-38,-38,-38,-38,-38
S,GrayMap,"Given a generalized Hadamard matrix H over GF(p) of length p^(s-1), for an integer s > 1, this function returns the generalized Gray map phi_s from Z/p^s to GF(p)^(p^(s-1)) given by H. The matrix must have zeros in the first row, but it does not need to be normalized. Matrix H can also be given as an ordinary Hadamard matrix with 1's and -1's. In this case, it is transformed into a binary matrix by swapping 1's for 0's and -1's for 1's. Note that if H is the Sylvester Hadamard matrix, which is the matrix generated by all linear combinations of the rows of a matrix Y_(s-1) of size (s-1) x p^(s-1) whose columns are all the vectors in GF(p)^(s-1), then this map coincides with the one given by function GrayMap(p, s)",0,1,0,0,0,0,0,0,0,177,,175,-38,-38,-38,-38,-38
S,GrayMap,"Given a linear code C over Z/p^s of length n and a generalized Hadamard matrix H over GF(p) of order p^(s-1), for an integer s>1, this function returns the generalized Gray map Phi_s from C to GF(p)^(n*p^(s-1)) given by H applied to each coordinate. The matrix must have zeros in the first row, but it does not need to be normalized. Matrix H can also be given as an ordinary Hadamard matrix with 1's and -1's. In this case, it is transformed into a binary matrix by swapping 1's for 0's and -1's for 1's. Note that if H is the Sylvester Hadamard matrix, which is the matrix generated by all linear combinations of the rows of a matrix Y_(s-1) of size (s-1) x p^(s-1) whose columns are all the vectors in GF(p)^(s-1), then this map coincides with the one given by function GrayMap(C)",0,2,0,0,0,0,0,0,0,177,,0,0,202,,175,-38,-38,-38,-38,-38
S,GrayMapImage,"Given a linear code C over Z/p^s of length n and a generalized Hadamard matrix H over GF(p) of order p^(s-1), for an integer s>1, this function returns the image of C under the generalized Gray map Phi_s from C to GF(p)^(n*p^(s-1)) given by H applied to each coordinate. As the resulting image may not be a linear code over GF(p), a sequence of vectors in GF(p)^(n*p^(s-1)) is returned rather than a code. The matrix must have zeros in the first row, but it does not need to be normalized. Matrix H can also be given as an ordinary Hadamard matrix with 1's and -1's. In this case, it is transformed into a binary matrix by swapping 1's for 0's and -1's for 1's. Note that if H is the Sylvester Hadamard matrix, which is the matrix generated by all linear combinations of the rows of a matrix Y_(s-1) of size (s-1) x p^(s-1) whose columns are all the vectors in GF(p)^(s-1), then this map coincides with the one given by function GrayMapImage(C)",0,2,0,0,0,0,0,0,0,177,,0,0,202,,82,-38,-38,-38,-38,-38
S,HasLinearGrayMapImage,"Given a linear code C over Z/p^s of length n and a generalized Hadamard matrix over GF(p) of order p^(s-1), for an integer s>1, this function returns true if and only if the image of C under the generalized Gray map Phi_s from C to GF(p)^(n*p^(s-1)) given by H applied to each coordinate, is a linear code over GF(p). If so, the function also returns the image C_p as a linear code over GF(p), together with the bijection Phi_s: C -> C_p. Matrix H can also be given as an ordinary Hadamard matrix with 1's and -1's. In this case, it is transformed into a binary matrix by swapping 1's for 0's and -1's for 1's",0,2,0,0,0,0,0,0,0,177,,0,0,202,,36,202,175,-38,-38,-38
S,ZpStandardForm,"Given a linear code C over Z/p^s, return a permutation-equivalent code S in standard form, together with the corresponding isomorphism from C onto S. It also returns the generator matrix in standard form used to generate the code S and the permutation x such that C^x = S. Magma returns one of the many codes in standard form which is isomorphic to C (the same code is returned each time). The parameter IsReducedStandardForm specifies whether the generator matrix is given as a matrix in reduced standard form. The default value is false. If it is set to true, the function returns a generator matrix which is in reduced standard form. If C is a linear code over Z4, the first two output parameters coincide with the ones given by the function StandardForm(C), and the last two parameters with the first and forth ones given by StandardFormInfo(C)",0,1,0,0,0,0,0,0,0,202,,202,175,190,222,-38,-38
S,IsStandardFormMatrix,"Given a matrix G over Z/p^s, return true if and only if G is a generator matrix in standard form. The parameter IsReducedStandardForm is set to false by default. If it is set to true, the function returns true if and only if G is in reduced standard form",0,1,0,0,0,0,0,0,0,-34,,36,-38,-38,-38,-38,-38
S,ZpMinRowsGeneratorMatrix,"A generator matrix for the linear code C over Z/p^s of type (n; t1,...,ts), with the minimum number of rows, that is with t1+...+ts rows: t1 rows of order p^s, t2 of order p^(s-1), and so on until ts rows of order p. It also returns the sequence [t1,...,ts] and a permutation transforming C into a permutation-equivalent code with generator matrix in standard form. If C is a linear code over Z4 of type (n; t1, t2), to obtain a generator matrix with minimum number of rows, function MinRowsGeneratorMatrix(C) can also be used. However, instead of returning the sequence [t1, t2], it returns t2, t1, and the generator matrix may be different",0,1,0,0,0,0,0,0,0,202,,190,82,222,-38,-38,-38
S,ZpPseudoDimension,"Given a linear code C over Z/p^s of type (n; t1,..ts), return the value st_1+(s-1)t_2+... + t_s. Note that |C|=p^(st_1+(s-1)t_2+dots + t_s). Function PseudoDimension(C), for linear codes over rings in general, return the number of generators of the linear code C, that is, t_1+t_2+...+t_s",0,1,0,0,0,0,0,0,0,202,,IntRngElt,-38,-38,-38,-38,-38
S,ZpInformationRate,"Given a linear code C over Z/p^s of type (n; t1,..ts), return the information rate of C, that is the ratio (st1 + (s-1)t2 + ...+ ts) / (n*s)",0,1,0,0,0,0,0,0,0,202,,267,-38,-38,-38,-38,-38
S,ZpType,"Given a linear code C over Z/p^s of length n, return the type of the code, that is, the unique sequence [t1,...,ts] such that the code, as a subgroup of (Z/p^s)^n, is isomorphic to (Z/p^s)^t1 x (Z/p^(s-1))^t2 x ··· x Zp^ts",0,1,0,0,0,0,0,0,0,202,,82,-38,-38,-38,-38,-38
S,ZpTypeDual,"Given a linear code C over Z/p^s of type (n; t1,...,ts), return the type of the dual code of C, that is, the sequence [n-t1-t2-...-ts, ts, ..., t2]",0,1,0,0,0,0,0,0,0,202,,82,-38,-38,-38,-38,-38
S,ZpDual,"Given a linear code C over Z/p^s of type (n; t1,...,ts), return the dual code D of C. The dual code consists of all codewords in the (Z/p^s)-space V=(Z/p^s)^n which are orthogonal to all codewords of C. In particular, the dual code D is of type (n; n-t1-t2-...-ts, ts, t_(s-1),..., t_2). This function creates the generator matrix of D using a specific known structure based on the generator matrix of C. This construction improves the computation time with respect to the generic function Dual(C) for codes over rings. If C is over Z4, function ZpDual(C) coincides with function DualZ4(C), but the former may perform less efficiently in general",0,1,0,0,0,0,0,0,0,202,,202,-38,-38,-38,-38,-38
S,ZpStandardFormDual,"Given a linear code C over Z/p^s, return the dual of a permutation-equivalent code S in standard form, together with the corresponding isomorphism from the dual of C onto the dual of S. It also returns the parity check matrix used to generate the dual code of S and the permutation x such that (C^perp)^x = S^perp. Magma returns one of the many codes which is isomorphic to C^perp (the same code is returned each time). If C is a linear code over Z4, the first two output parameters coincide with the ones given by the function StandardFormDual(C)",0,1,0,0,0,0,0,0,0,202,,202,175,190,222,-38,-38
S,ZpMinRowsParityCheckMatrix,"A parity check matrix for the linear code C over Z/p^s of type (n; t1,...,ts), with the minimum number of rows, that is, with n-t1 rows. It also returns the sequence [n-t1-t2-...-ts, ts, ..., t2] and a permutation transforming C^perp into a permutation-equivalent code with generator matrix in standard form. This function should be faster for most codes over Z/p^s than the general function ParityCheckMatrix(C) for codes over finite rings. Another parity check matrix for the code C can be obtained as the generator matrix of the dual of C with the minimum number of rows, that is, as ZpMinRowsGeneratorMatrix(ZpDual(C)). If C is a linear code over Z4 of type (n; t1, t2), then MinRowsParityCheckMatrix(C) can also be used to obtain a parity check matrix with minimum number of rows. However, only the matrix is returned, which may not coincide with the one given by ZpMinRowsGeneratorMatrix(C)",0,1,0,0,0,0,0,0,0,202,,190,82,222,-38,-38,-38
S,CosetRepresentatives,"Given a linear code C over Z/p^s of length n, with ambient space V = (Z/p^s)^n, return a set of coset representatives (not necessarily of minimal weight in their cosets) for C in V as an indexed set of vectors from V. The set of coset representatives [c_0, c_1,..., c_t] satisfies that c_0 is the zero codeword and V = U_(i=0)^t (C + c_i). Note that this function is only applicable when V and C are small",0,1,0,0,0,0,0,0,0,202,,151,-38,-38,-38,-38,-38
S,CosetRepresentatives,"Given a linear code C over Z/p^s of length n, and a subcode S over Z/p^s of C, return a set of coset representatives (not necessarily of minimal weight in their cosets) for S in C as an indexed set of codewords from C. The set of coset representatives [c_0, c_1,..., c_t] satisfies that c_0 is the zero codeword and C = U_(i=0)^t (S + c_i). The function also returns a second set containing the images of the coset representatives [c_0, c_1,..., c_t] by Carlet's generalized Gray map. Note that this function is only applicable when S and C are small",0,2,0,0,0,0,0,0,0,202,,0,0,202,,151,151,-38,-38,-38,-38
S,GrayMap,"Given a generalized Hadamard matrix H over GF(p) of length p^(s-1), for an integer s > 1, this function returns the generalized Gray map phi_s from Z/p^s to GF(p)^(p^(s-1)) given by H. The matrix must have zeros in the first row, but it does not need to be normalized. Matrix H can also be given as an ordinary Hadamard matrix with 1's and -1's. In this case, it is transformed into a binary matrix by swapping 1's for 0's and -1's for 1's. Note that if H is the Sylvester Hadamard matrix, which is the matrix generated by all linear combinations of the rows of a matrix Y_(s-1) of size (s-1) x p^(s-1) whose columns are all the vectors in GF(p)^(s-1), then this map coincides with the one given by function GrayMap(p, s)",0,1,0,0,0,0,0,0,0,82,,175,-38,-38,-38,-38,-38
