/************************************************************/
/*                                                          */
/* Project name: Z/p^s-additive codes in MAGMA              */
/* Test file name: ZpStandardForm_BB_test.m                 */
/*                                                          */
/* Comments: Black-box tests for the functions              */
/*           ZpStandardForm                                 */
/*           IsStandardFormMatrix                           */
/*           included in the ZpAdditiveCodes_Core.m file    */
/*                                                          */
/* Authors: Noam von Rotberg, Mercè Villanueva and          */
/*          Adrián Torres                                   */
/*                                                          */
/* Revision version and last date: v1.0   2021/08/28        */
/*                                 v1.1   2021/10/08        */
/*                                                          */
/************************************************************/

SetAssertions(true);
// Alarm(30*60);

////////////////////////////////////////////////////////////////////////////////
///////                                                                 ////////
///////      CODES WITH GENERATOR MATRICES IN STANDARD FORM             ////////  
///////                                                                 ////////
////////////////////////////////////////////////////////////////////////////////

/****************************************************************/
/*                                                              */
/* Function name: TestZpStandardForm_StdForm                    */
/* Parameters: p, s, G, testNumber                              */
/* Description: Given a prime p, a positive integer s, a matrix */
/*   in standard form (so it does not need a permutation of     */
/*   columns to be transformed into a matrix in standard form), */
/*   and an integer with the testNumber, test the following:    */
/*   - input and output matrices are in standard form           */
/*   - output code is equal to C=LinearCode(G)                  */
/*   - output code is generated by the output matrix            */ 
/*   - output permutation is the identity                       */
/*   - output map is the identity map for a random codeword     */
/*   - output map has domain and codomain equal to C            */
/*   - output code has correct type                             */
/*   - output code has correct length                           */
/*   - output code has correct base ring                        */
/*   - output matrix has correct base ring                      */
/* Input parameters description:                                */
/*   - p: a prime                                               */
/*   - s: an integer describing the base ring Integers(p^s)     */
/*   - G: a matrix over Integers(p^s)                           */
/*   - testNumber: an integer being printed as test number      */
/* Output parameters description:                               */
/*   - testNumber: the by one increased integer                 */
/*                                                              */
/****************************************************************/
TestZpStandardForm_StdForm := procedure(p, s, G, ~testNumber)
    Zps := Integers(p^s);
    C := LinearCode(G);
    type := ZpType(C);
    n := Length(C);
    expectedOutputCode := C;
    expectedOutputPermutation := Sym(n)!1;
    expectedOutputMap := map <C -> C | x:-> x, y:->y>;
    codeword := Random(C);

    outputCode, outputMap, outputMatrix, outputPermutation := ZpStandardForm(C);

    print "Test 1.", testNumber,": Standard-form code over over Z/", p, "^", s, "of length", n;
    
    assert IsStandardFormMatrix(G);
    assert IsStandardFormMatrix(outputMatrix);
    assert outputCode eq expectedOutputCode;
    assert outputCode eq LinearCode(outputMatrix);
    assert outputPermutation eq expectedOutputPermutation;
    assert outputMap(codeword) eq expectedOutputMap(codeword);
    assert Domain(outputMap) eq C;
    assert Codomain(outputMap) eq C; 
    assert BaseRing(outputCode) eq Zps;
    assert BaseRing(outputMatrix) eq Zps;
    assert ZpType(outputCode) eq type; 
    assert Length(outputCode) eq n;

    testNumber +:= 1;

end procedure;

/****************************************************************/
// counter for test number
testNumber := 1; 

/****************************************************************/
/*    Test zero, universe and repetion codes                    */
/****************************************************************/
p := 5;
s := 2;
G := Matrix(Integers(p^s), 0, 10, []);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 2;
s := 3;
G := Matrix(Integers(p^s), 0, 10, []);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 5;
s := 4;
G := Matrix(Integers(p^s), 0, 13, []);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 3;
s := 4;
G := IdentityMatrix(Integers(p^s), 6);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 7;
s := 2;
G := Matrix(Integers(p^s), [[1^^20]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
/*   Test codes of type with one non-zero entry                 */
/****************************************************************/
p := 7;
s := 4;
G := Matrix(Integers(p^s), [[1, 3, 8, 2, 10, 4]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 3;
s := 5;
G := Matrix(Integers(p^s), [[9, 0, 0, 27, 9, 9, 0, 81, 243, 27, 0]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 2;
s := 7;
G := Matrix(Integers(p^s), [[ 4, 0, 16],
                            [ 0, 4, 64]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
/*   Test codes of type with two non-zero entry                 */
/****************************************************************/
p := 2;
s := 7;
G := Matrix(Integers(p^s), [[ 2,  6,  8,  2, 10], 
                            [ 0, 16, 32, 16, 64]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 11;
s := 3;
G := Matrix(Integers(p^s), [[ 1,  99,  10,   3,   0, 402], 
                            [ 0, 121,   0,   0,   0, 121],
                            [ 0,   0, 121,   0, 121, 121],
                            [ 0,   0,   0, 121,   0, 121]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 3;
s := 3;
G := Matrix(Integers(p^s), [[ 1, 7, 3, 6, 2],
                            [ 0, 3, 6, 0, 9]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 5;
s := 4;
G := Matrix(Integers(p^s), [[ 5,  5,  15,   0, 125, 25],
                            [ 0, 25,   0, 150, 225, 25],
                            [ 0,  0, 125,   0, 375,  0]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 5;
s := 8;
G := Matrix(Integers(p^s), [[ 1, 24,  3, 438,    2, 39273,      1,  9],
                            [ 0,  5, 30,   0,  445,     0,   4505, 10],
                            [ 0,  0, 25, 625, 2000,   125,  83750,  0],
                            [ 0,  0,  0, 125, 1625,     0,    375,  0],
                            [ 0,  0,  0,   0, 3125,  6250,      0,  0],
                            [ 0,  0,  0,   0,    0, 78125, 234375,  0]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 131;
s := 11;
G := Matrix(Integers(p^s), [[ 2248091,        24729001,                 0],
                            [       0, 662062621900811,  3310313109504055],
                            [       0,               0, 86730203469006241]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 11;
s := 2;
G := Matrix(Integers(p^s), [[ 11]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 7;
s := 3;
G := Matrix(Integers(p^s), [[ 1, 53, 331, 154],
                            [ 0,  7,  21,   0],
                            [ 0,  0,  49, 245]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 3;
s := 5;
G := Matrix(Integers(p^s), [[ 1, 17,  23, 66,  2,  0,  52],
                            [ 0,  3, 105,  0,  9,  3,  81],
                            [ 0,  0,   9,  0, 18, 36,  54],
                            [ 0,  0,   0, 27, 81, 54, 108],
                            [ 0,  0,   0,  0, 81,  0, 162]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
/*   Test codes of type with no zero entries                    */
/****************************************************************/
p := 2;
s := 7;
G := Matrix(Integers(p^s), [[ 2,  6,  8,  2, 10], 
                            [ 0, 16, 32, 16, 64]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 5;
s := 3;
G := Matrix(Integers(p^s), [[ 1, 0, 8,  3, 10,   0, 14], 
                            [ 0, 5, 0, 30,  0, 105,  0],
                            [ 0, 0, 5,  0, 15,   0, 80],
                            [ 0, 0, 0, 25,  0,  25,  0]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 2;
s := 3;
G := Matrix(Integers(p^s), [[ 1, 7, 3, 6, 2, 4],
                            [ 0, 2, 6, 0, 4, 4],
                            [ 0, 0, 4, 0, 4, 0]]);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
/*   Test codes generated using RandomZpAdditiveCode            */
/****************************************************************/
p := 31;
n := 26;
type := [ 15, 7];
s := #type;
_, G := RandomZpAdditiveCode(p, n, type);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 3;
s := 5;
n := 10;
k := 6;
C := RandomLinearCode(Integers(p^s), n, k);
G := GeneratorMatrix(C);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

/****************************************************************/
p := 5;
s := 4;
n := 12;
k := 10;
C := RandomLinearCode(Integers(p^s), n, k);
G := GeneratorMatrix(C);
TestZpStandardForm_StdForm(p, s, G, ~testNumber);

////////////////////////////////////////////////////////////////////////////////
///////                                                                 ////////
///////        CODES WITH GENERATOR MATRICES NOT IN STANDARD FORM       ////////
///////         THEY ARE SYSTEMATIC AFTER AN IDENTITY PERMUTATION       ////////
///////                                                                 ////////
////////////////////////////////////////////////////////////////////////////////

/****************************************************************/
/*                                                              */
/* Function name: TestZpStandardForm_IdPerm                     */
/* Parameters: p, s, G, testNumber                              */
/* Description: Given a prime p, a positive integer s, a matrix */
/*   NOT in standard form but does not need a permutation of    */
/*   columns to be transformed into a matrix in standard form), */
/*   and an integer with the testNumber, test the following:    */
/*   - input matrix is not in standard form                     */
/*   - output matrix is in standard form                        */
/*   - output code is equal to C=LinearCode(G)                  */
/*   - output code is generated by the output matrix            */ 
/*   - output permutation is the identity                       */
/*   - output map is the identity map for a random codeword     */
/*   - output map has domain and codomain equal to C            */
/*   - output code has correct type                             */
/*   - output code has correct length                           */
/*   - output code has correct base ring                        */
/*   - output matrix has correct base ring                      */
/* Input parameters description:                                */
/*   - p: a prime                                               */
/*   - s: an integer describing the base ring Integers(p^s)     */
/*   - G: a matrix over Integers(p^s)                           */
/*   - testNumber: an integer being printed as test number      */
/* Output parameters description:                               */
/*   - testNumber: the by one increased integer                 */
/*                                                              */
/****************************************************************/
TestZpStandardForm_IdPerm := procedure(p, s, G, ~testNumber)
    Zps := Integers(p^s);
    C := LinearCode(G);
    type := ZpType(C);
    n := Length(C);
    expectedOutputCode := C;
    expectedOutputPermutation := Sym(n)!1;
    expectedOutputMap := map <C -> C | x:-> x, y:->y>;
    codeword := Random(C);

    outputCode, outputMap, outputMatrix, outputPermutation := ZpStandardForm(C);

    print "Test 2.", testNumber,": Not standard-form code over over Z/", p, "^", s, "of length", n;
    
    assert not IsStandardFormMatrix(G);
    assert IsStandardFormMatrix(outputMatrix);
    assert outputCode eq expectedOutputCode;
    assert outputCode eq LinearCode(outputMatrix);
    assert outputPermutation eq expectedOutputPermutation;
    assert outputMap(codeword) eq expectedOutputMap(codeword);
    assert Domain(outputMap) eq C;
    assert Codomain(outputMap) eq C; 
    assert BaseRing(outputCode) eq Zps;
    assert BaseRing(outputMatrix) eq Zps;
    assert ZpType(outputCode) eq type; 
    assert Length(outputCode) eq n;

    testNumber +:= 1;

end procedure;

/****************************************************************/
// counter for test number
testNumber := 1; 

/****************************************************************/
p := 7;
s := 10;
G := Matrix(Integers(p^s), [[  91738268,  75805635,  14955749, 267483941, 176639619, 235611219, 187152262,    900573,  50282244, 115369348],
                            [  98884359, 216736964, 172260604,  77801910, 143258633,  10496949, 164359284,  17863536,  84576640,   1292903],
                            [  51414836, 116267675, 122250904, 260428176, 115687268,  14059002, 245307415,  61868708,  14191400, 267981925],
                            [         0,         0,         0,         0,         0,         0,         0,         0,         0,         0],
                            [ 262180638, 141321144,  43312016, 124919242,  77100111, 136788184, 258078808,  37973177, 101156722, 190268612],
                            [  29989789,    616511,  83501752,  27374041, 141668263, 163224799, 255000518, 155751724, 132918008,  13343228],
                            [  17120097, 222389727,  97210193, 178993512, 201215497, 203819400,  13179528, 275647838,  91270019, 173648483]]);
TestZpStandardForm_IdPerm(p, s, G, ~testNumber);

/****************************************************************/
p := 7;
s := 2;
G := Matrix(Integers(p^s), [[1,2,3,4], 
                            [0,7,0,0], 
                            [9,0,7,49]]);
TestZpStandardForm_IdPerm(p, s, G, ~testNumber);

/****************************************************************/
p := 7;
s := 2;
G := Matrix(Integers(p^s), [[ 1, 0, 6, 3,  0], 
                            [ 0, 1, 0, 0,  5], 
                            [ 0, 0, 9, 0, 27], 
                            [ 0, 0, 0, 1,  9], 
                            [ 0, 0, 0, 0, 81]]);
TestZpStandardForm_IdPerm(p, s, G, ~testNumber);

/****************************************************************/
p := 11;
s := 3;
G := Matrix(Integers(p^s), [[ 1, 4, 6], 
                            [ 0, 1, 0]]);
TestZpStandardForm_IdPerm(p, s, G, ~testNumber);

////////////////////////////////////////////////////////////////////////////////
///////                                                                 ////////
///////        CODES WITH GENERATOR MATRICES NOT IN STANDARD FORM       ////////
///////       THEY ARE SYSTEMATIC AFTER A NON IDENTITY PERMUTATION      ////////
///////                                                                 ////////
////////////////////////////////////////////////////////////////////////////////

/****************************************************************/
/*                                                              */
/* Function name: TestZpStandardForm_NotIdPerm                  */
/* Parameters: p, s, G, perm, testNumber                        */
/* Description: Given a prime p, a positive integer s, a matrix */
/*   NOT in standard form which DOES need a permutation of      */
/*   columns to be transformed into a matrix in standard form), */
/*   and an integer with the testNumber, test the following:    */
/*   - input matrix is not in standard form                     */
/*   - output matrix is in standard form                        */
/*   - output code is equal to LinearCode(G)^perm               */
/*   - output code is generated by the output matrix            */ 
/*   - output permutation is equal to perm                      */
/*   - output map is the expected map for a random codeword     */
/*   - output map has domain equal to C                         */
/*   - output map has codomain equal to output code             */
/*   - output code has correct type                             */
/*   - output code has correct length                           */
/*   - output code has correct base ring                        */
/*   - output matrix has correct base ring                      */
/* Input parameters description:                                */
/*   - p: a prime                                               */
/*   - s: an integer describing the base ring Integers(p^s)     */
/*   - G: a matrix over Integers(p^s)                           */
/*   - perm: a permutation of Sym(n)                            */
/*   - testNumber: an integer being printed as test number      */
/* Output parameters description:                               */
/*   - testNumber: the by one increased integer                 */
/*                                                              */
/****************************************************************/
TestZpStandardForm_NotIdPerm := procedure(p, s, G, perm, ~testNumber)
    Zps := Integers(p^s);
    C := LinearCode(G);
    type := ZpType(C);
    n := Length(C);
    expectedOutputCode := LinearCode(G*PermutationMatrix(Zps, perm));
    expectedOutputPermutation := perm;
    expectedOutputMap := map <C -> expectedOutputCode | 
                              x:-> x^perm, y:->y^(perm^(-1))>;
    codeword := Random(C);

    outputCode, outputMap, outputMatrix, outputPermutation := ZpStandardForm(C);

    print "Test 3.", testNumber,": Not standard-form code over over Z/", p, "^", s, "of length", n;
    
    assert not IsStandardFormMatrix(G);
    assert IsStandardFormMatrix(outputMatrix);
    assert outputCode eq expectedOutputCode;
    assert outputCode eq LinearCode(outputMatrix);
    assert outputPermutation eq expectedOutputPermutation;
    assert outputMap(codeword) eq expectedOutputMap(codeword);
    assert Domain(outputMap) eq C;
    assert Codomain(outputMap) eq outputCode; 
    assert BaseRing(outputCode) eq Zps;
    assert BaseRing(outputMatrix) eq Zps;
    assert ZpType(outputCode) eq type; 
    assert Length(outputCode) eq n;
    
    testNumber +:= 1;

end procedure;

/****************************************************************/
// counter for test number
testNumber := 1; 

/****************************************************************/
p := 2;
s := 3;
G := Matrix(Integers(p^s), [[2, 2, 6, 0, 7, 0, 3, 1, 5, 6],
                            [0, 1, 1, 2, 0, 0, 7, 5, 7, 2],
                            [0, 0, 6, 0, 4, 0, 0, 6, 0, 3],
                            [0, 6, 0, 0, 6, 0, 0, 6, 6, 0],
                            [0, 6, 0, 5, 0, 0, 0, 3, 1, 0],
                            [0, 0, 0, 4, 0, 0, 0, 5, 0, 2],
                            [0, 0, 0, 5, 0, 0, 0, 2, 3, 0],
                            [0, 0, 0, 3, 0, 0, 0, 5, 1, 3]]);
perm := Sym(10)!(1, 9, 7, 8, 4, 3, 6, 10, 5);
TestZpStandardForm_NotIdPerm(p, s, G, perm, ~testNumber);

/****************************************************************/
p := 7;
s := 5;
G := Matrix(Integers(p^s), [[0,0,3,0,5,1,7,6,5,6],
                            [4,5,7,5,0,6,7,5,1,1],
                            [7,5,4,0,5,6,7,3,5,5],
                            [0,2,2,1,1,0,7,0,0,3],
                            [7,7,6,1,5,6,0,5,1,4],
                            [4,5,7,5,2,6,2,6,1,6]]);
perm := Sym(10)!(6,7);
TestZpStandardForm_NotIdPerm(p, s, G, perm, ~testNumber);

/****************************************************************/
p := 7;
s := 8;
G := Matrix(Integers(p^s), [[ 1,0,8, 3,10,  0,14], 
                            [ 0,1,0,37, 0,108, 0],
                            [ 0,0,7, 0,14,  0,84],
                            [ 0,0,0, 5, 0, 49, 0]]);
perm := Sym(7)!(3,4);
TestZpStandardForm_NotIdPerm(p, s, G, perm, ~testNumber);

/****************************************************************/
p := 2;
s := 4;
G := Matrix(Integers(p^s), [[ 2, 0, 2, 1], 
                            [ 0, 2, 2, 0]]);
perm := Sym(4)!(1,3,4);
TestZpStandardForm_NotIdPerm(p, s, G, perm, ~testNumber);

/****************************************************************/
p := 3;
s := 3;
C := ZpHadamardCode(3, [1,1,3]);
G := GeneratorMatrix(C);
perm := Sym(243)!(3,10)(4,28)(5,82);
TestZpStandardForm_NotIdPerm(p, s, G, perm, ~testNumber);

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///////           DOES THE SAME AS Z/4-STANDARD FORM                    ////////  
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/****************************************************************/
/*                                                              */
/* Function name: TestZpStandardForm_Z4Codes                    */
/* Parameters: C, testNumber                                    */
/* Description: Given a linear code C over Z/4, test whether    */
/*   ZpStandardForm(C) gives resonable output and compares it   */
/*   to the output of the already implemented StandardForm for  */
/*   codes over Z/4. In particular, it checks the following:    */
/*   - output matrix is in standard form                        */
/*   - output code is the same as output code of StandardForm   */
/*   - output code is generated by the output matrix            */
/*   - output matrix is equal to expected matrix                */
/*   - output permutation is equal to expected permutation      */
/*   - output map is the expected map for a random codeword     */
/*   - output map has domain equal to C                         */
/*   - output map has codomain equal to output code             */
/*   - output code has correct type                             */
/*   - output code has correct type given by ZpType             */
/*   - output code has correct length                           */
/*   - output code has correct base ring                        */
/*   - output matrix has correct base ring                      */
/* Input parameters description:                                */
/*   - C: a linear code over Z/4,                               */
/*   - testNumber: an integer being printed as test number      */
/* Output parameters description:                               */
/*   - testNumber: the by one increased integer                 */
/*                                                              */
/****************************************************************/
TestZpStandardForm_Z4Codes := procedure(C, ~testNumber)
    Zps := Integers(4);
    type := ZpType(C);
    n := Length(C);
    delta, gamma := Z4Type(C);
    expectedOutputCode, expectedOutputMap := StandardForm(C);
    expectedOutputMatrix, _, _, expectedOutputPermutation := StandardFormInfo(C);
    codeword := Random(C);               
    
    outputCode, outputMap, outputMatrix, outputPermutation := ZpStandardForm(C);

    print "Test 4.", testNumber,": Code over Z/4,of length", n, "and type", type;

    assert IsStandardFormMatrix(outputMatrix);
    assert outputCode eq expectedOutputCode;
    assert outputCode eq LinearCode(outputMatrix);
    assert outputPermutation eq expectedOutputPermutation;
    assert outputMatrix eq expectedOutputMatrix;
    assert outputMap(codeword) eq expectedOutputMap(codeword);
    assert Domain(outputMap) eq C;
    assert Codomain(outputMap) eq outputCode; 
    assert BaseRing(outputCode) eq Zps;
    assert BaseRing(outputMatrix) eq Zps;
    assert ZpType(outputCode) eq type; 
    assert [delta, gamma] eq type;
    assert Length(outputCode) eq n;

    testNumber +:=1;

end procedure;

/****************************************************************/
// here, Z/p^s is fixed
Zps := Integers(4);

// counter for test number
testNumber := 1; 

/****************************************************************/
C := ZeroCode(Zps, 6);
TestZpStandardForm_Z4Codes(C,~testNumber);

/****************************************************************/
C := RepetitionCode(Zps, 8);
TestZpStandardForm_Z4Codes(C,~testNumber);

/****************************************************************/
C := UniverseCode(Zps, 7);
TestZpStandardForm_Z4Codes(C,~testNumber);

/****************************************************************/
C := PreparataCode(3);
TestZpStandardForm_Z4Codes(C,~testNumber);

/****************************************************************/
C := KerdockCode(4);
TestZpStandardForm_Z4Codes(C,~testNumber);

/****************************************************************/
C := ReedMullerCodeZ4(2, 4);
TestZpStandardForm_Z4Codes(C,~testNumber);

/****************************************************************/
C := HadamardCodeZ4(3, 5);
TestZpStandardForm_Z4Codes(C,~testNumber);

/****************************************************************/
C := RandomLinearCode(Zps, 10, 5);
TestZpStandardForm_Z4Codes(C,~testNumber);

/****************************************************************/
G := Matrix(Zps, [[ 3, 1, 3, 0, 0, 1, 1],
                  [ 0, 0, 4, 0, 0, 0, 4],
                  [ 2, 2, 2, 2, 2, 3, 3],
                  [ 0, 2, 4, 0, 6, 2, 4],
                  [ 0, 0, 0, 4, 0, 0, 4],
                  [ 0, 2, 1, 1, 0, 1, 3]]);
C := LinearCode(G);
TestZpStandardForm_Z4Codes(C,~testNumber);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///////                    MINROWSGENERATORMATRIX                       ////////  
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/********************************************************************/
/*                                                                  */
/* Function name: TestZpStandardForm_NotMinRows                     */
/* Parameters: p, s, G, testNumber                                  */
/* Description: Given a prime p, a positive integer s, a matrix     */
/*   G NOT with the minimum number of rows and an integer with      */
/*   the testNumber, test the following:                            */
/*   - input matrix is not in standard form                         */
/*   - generator matrix of C is not in standard form                */
/*   - input matrix does not have minimum number of rows            */
/*   - generator matrix does not have minimum number of rows        */
/*   - code generated from output matrix is equal to C              */
/*   - output matrix has correct base ring                          */
/*   - output matrix has minimum number of rows                     */
/*   - output matrix is equal to std. form matrix after permutation */
/*   - output type is correct                                       */
/* Input parameters description:                                    */
/*   - p: a prime                                                   */
/*   - s: an integer describing the base ring Integers(p^s)         */
/*   - G: a matrix over Integers(p^s)                               */
/*   - testNumber: an integer being printed as test number          */
/*                                                                  */
/********************************************************************/
TestZpStandardForm_NotMinRows := procedure(p, s, G, ~testNumber)
    Zps := Integers(p^s);
    C := LinearCode(G);
    type := ZpType(C);
    n := Length(C);
    // expectedOutputCode := LinearCode(G*PermutationMatrix(Zps, perm));
    // expectedOutputPermutation := perm;
    // expectedOutputMap := map <C -> expectedOutputCode | 
    //                           x:-> x^perm, y:->y^(perm^(-1))>;
    // codeword := Random(C);
    _, _, expectedStandardMatrix := ZpStandardForm(C);
    Gc := GeneratorMatrix(C);

    outputMatrix, outputType, outputPerm := ZpMinRowsGeneratorMatrix(C);

    print "Test 5.", testNumber,": Not MinRows code over over Z/", p, "^", s, "of length", n;
    
    assert not IsStandardFormMatrix(G);
    assert not IsStandardFormMatrix(Gc);
    assert Nrows(G) gt &+type;
    assert Nrows(Gc) gt &+type;
    assert LinearCode(outputMatrix) eq C;
    assert BaseRing(outputMatrix) eq Zps;
    assert Nrows(outputMatrix) eq &+type;
    assert outputMatrix^outputPerm eq expectedStandardMatrix;
    assert outputType eq type;
    // assert outputMap(codeword) eq expectedOutputMap(codeword);
    
    testNumber +:= 1;

end procedure;

/****************************************************************/
// counter for test number
testNumber := 1; 

/****************************************************************/
p := 2;
s := 3;
G := Matrix(Integers(p^s), [[1,0,2,1],
                            [0,1,1,0],
                            [0,0,4,1],
                            [0,0,0,2]]);
TestZpStandardForm_NotMinRows(p, s, G, ~testNumber);

/****************************************************************/
p := 2;
s := 3;
G := Matrix(Integers(p^s),[[1,0,2,5,2],
                         [0,2,2,3,0],
                         [0,0,0,4,0],
                         [0,0,4,0,3],
                         [0,0,0,0,6]]);
TestZpStandardForm_NotMinRows(p, s, G, ~testNumber);

/****************************************************************/
p := 3;
s := 3;
G := Matrix(Integers(p^s), [[ 1,0,0,1,6,8,24,16,25,19],
                            [ 0,1,0,2,7,8,2,4,1,0],
                            [ 0,0,1,0,7,7,7,5,24,22],
                            [ 0,0,0,3,8,3,10,12,14,17],
                            [ 0,0,0,0,9,0,18,0,9,9],
                            [ 0,0,0,0,0,9,18,18,9,0]]);
TestZpStandardForm_NotMinRows(p, s, G, ~testNumber);

/****************************************************************/
p := 5;
s := 2;
G := Matrix(Integers(p^s), [[ 1,0,0,0,3,1,8,16,7,18],
                            [ 0,1,0,0,2,4,18,22,15,3],
                            [ 0,0,1,3,0,0,16,11,20,0],
                            [ 0,0,0,5,0,4,23,6,20,10],
                            [ 0,0,0,0,5,2,19,3,5,15],
                            [ 0,0,0,0,0,5,10,20,0,0]]);
TestZpStandardForm_NotMinRows(p, s, G, ~testNumber);
